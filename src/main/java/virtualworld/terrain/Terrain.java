package virtualworld.terrain;

public class Terrain {
	
	public static void main(String[] args) {
	    
		Terrain t = new Terrain(new Pair<Double, Double>(0.0,0.0), 100, 10);
		
		double[][] render = t.renderHeights();
		
		for (double[] a : render) {
			for (double height : a) {
				System.out.print(height + " ");
			}
			System.out.print("\n");
		}
	    
	}
	
    // (x, z) coordinate of the terrain center
	//private final Pair<Double, Double> center;
	private final Pair<Double, Double> center;
	private final Perlin perlNoise = Perlin.getInstance();

    // length and points per side of the area that the terrain covers.
    private final double length;
    private final int sides;
    
	
	public Terrain(Pair<Double, Double> c, double len, int side) {
		center = c;
        length = len;
        sides = side;
	}

    //returns a pair that represents the center of the terrain object
    public Pair<Double, Double> getCenter() {
        return center;
    }

    // splits the terrain object into four separate terrain objects
    public Terrain[] split() {
        return new Terrain[] {
            new Terrain(
                new Pair<Double, Double>(
                		center.getLeft() - (length/4), 
                		center.getRight() - (length/4)),
                length,
                sides),
            new Terrain(
                new Pair<Double, Double>(
                		center.getLeft() + (length/4), 
                		center.getRight() - (length/4)),
                length,
                sides),
            new Terrain(
                new Pair<Double, Double>(
                		center.getLeft() - (length/4), 
                		center.getRight() + (length/4)),
                length,
                sides),
            new Terrain(
                new Pair<Double, Double>(
                		center.getLeft() + (length/4), 
                		center.getRight() + (length/4)),
                length,
                sides)
        };   
    }
    
    //generates a height map for terrain square
    public double[][] renderHeights() {
    	
    	double[][] generatedY = new double[sides][sides];
    	
    	generatedY[0][0] = 0.25;
    	
    	//int j = 0;
    	//int k = 0;
    	
    	double yOffset = (center.getLeft() - length/2) / 10;
    	for (int r = 0; r < sides; r++) {
    		double xOffset = (center.getRight() + length/2) / 10;
    		for (int c = 0; c < sides; c++) {
    			if (c == 0) {
    				if (r != 0) {
    					generatedY[r][c] = perlNoise.noise2D(xOffset, generatedY[r-1][c])  *10;
    					xOffset += 0.1;
    				}
    			} else if (r == 0){
    				if (c != 0) {
    					generatedY[r][c] = perlNoise.noise2D(xOffset, generatedY[r][c-1])  *10;
    					xOffset += 0.1;
    				}
    			}
    			else if (c != 0 && r != 0) {
    				generatedY[r][c] = ((perlNoise.noise2D(xOffset, generatedY[r][c-1]) + perlNoise.noise2D(xOffset, generatedY[r-1][c])) / 2) *10;
    				xOffset += 0.1;
    				System.out.println(generatedY[r][c]);
    			}
    		}
    		yOffset += 0.1;
    	}
    	
    	// Perlin Noise 3D Failed Code
    	/*for ( double r = (center.getLeft() - length/2); r <= (center.getLeft() + length/2); r += (length/sides)) {
    		for ( double c = (center.getRight() + length/2); c <= (center.getRight() - length/2); c -= (length/sides)) {
        		if (r == center.getLeft() - length/2) {
        			if (k != 0) {
        				//noise generated by preceding point in column
        				generatedY[j][k] = perlNoise.noise(r, generatedY[j][k-1], c);
        			}
        		} else if (c == center.getLeft() + length/2){
        			generatedY[j][k] = perlNoise.noise(r, generatedY[j-1][k], c);
        		} else {
        			//average of two closest points generated noise
        			generatedY[j][k] = perlNoise.noise(r, generatedY[j][k-1], c) + perlNoise.noise(r, generatedY[j-1][k], c) / 2;
        		}
    			k++;
        	}
    		j++;
    	}*/
    	
    	return generatedY;
    	
    }

}
